Index: Main/src/Table.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import java.util.*;\r\n\r\npublic class Table {\r\n    /**\r\n     * the table name\r\n     */\r\n    private String name;\r\n    /**\r\n     * unique table id assigned to table\r\n     */\r\n    private int tableID;\r\n    /*\r\n     * general id that serves as the offset for the table id\r\n     */\r\n    private static int GENERALTABLEID;\r\n    /**\r\n     * the attributes for all the columns in this table\r\n     */\r\n    private ArrayList<Attribute> attributes;\r\n    /**\r\n     * collection of all the records in this table\r\n     */\r\n    private ArrayList<Record> records;\r\n    /**\r\n     * object attribute for the primary key of this table\r\n     */\r\n    private Attribute primaryAttribute;\r\n    /**\r\n     * index of the primary attribute in the columns\r\n     */\r\n    private int primaryIndex;\r\n    /**\r\n     * maps the primary key of a record to a record object\r\n     */\r\n    private HashMap<Object, Record> recordsByPK;\r\n    /**\r\n     * maps the name of a column to its attribute object\r\n     */\r\n    private HashMap<String, Attribute> attributesByCol;\r\n    /**\r\n     * all the pages containing the records for this table\r\n     */\r\n    private ArrayList<Page> pages;\r\n\r\n    private Page mostRecentPage;\r\n\r\n    public Table(String name, ArrayList<Attribute> attributes) {\r\n        this.name = name;\r\n        this.tableID = GENERALTABLEID + 1;\r\n        this.attributes = attributes;\r\n        this.records = new ArrayList<>();\r\n        this.recordsByPK = new HashMap<>();\r\n        pages = new ArrayList<>();\r\n\r\n        // set the primary attribute and primary index\r\n        for (int i = 0; i < attributes.size(); i++) {\r\n            Attribute a = attributes.get(i);\r\n            if (a.isIsPrimaryKey()) {\r\n                primaryAttribute = a;\r\n                primaryIndex = i;\r\n            }\r\n        }\r\n        setAttributesByCol();\r\n    }\r\n\r\n    /**\r\n     * sets the static offset for table id's\r\n     * table id's start at 1000\r\n     * \r\n     * @param id the table number which indicates how many tables exists\r\n     */\r\n    public static void setGeneralTableID(int id) {\r\n        GENERALTABLEID = 1000 + id;\r\n    }\r\n\r\n    /**\r\n     * @return String return the table name\r\n     */\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    /**\r\n     * @return int return the tableID\r\n     */\r\n    public int getTableID() {\r\n        return tableID;\r\n    }\r\n\r\n    public Page getMostRecentPage(){\r\n        return mostRecentPage;\r\n    }\r\n\r\n    /**\r\n     * sets the primary attribute\r\n     * \r\n     * @param primaryAttribute Attribute object that represents primary col\r\n     */\r\n    public void setPrimaryAttribute(Attribute primaryAttribute) {\r\n        this.primaryAttribute = primaryAttribute;\r\n    }\r\n\r\n    /**\r\n     * @return ArrayList<Attribute> return the attributes\r\n     */\r\n    public ArrayList<Attribute> getAttributes() {\r\n        return attributes;\r\n    }\r\n\r\n    /**\r\n     * @param attributes the attributes to set\r\n     */\r\n    public void setAttributes(ArrayList<Attribute> attributes) {\r\n        this.attributes = attributes;\r\n        setAttributesByCol();\r\n    }\r\n\r\n    /**\r\n     * returns the attribute object that corresponds to a\r\n     * specific column name\r\n     */\r\n    public void setAttributesByCol() {\r\n        this.attributesByCol = new HashMap<>();\r\n        for (Attribute attribute : this.attributes) {\r\n            attributesByCol.put(attribute.getName(), attribute);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return ArrayList<Record> return the records\r\n     */\r\n    public ArrayList<Record> getRecords() {\r\n        return records;\r\n    }\r\n\r\n    /*\r\n     * returns a re\r\n     */\r\n    public Record getRecordByPK(String pkValue) throws PrimaryKeyException, InvalidDataTypeException {\r\n        if (Type.validateType(pkValue, primaryAttribute)) {\r\n            if (recordsByPK.containsKey(pkValue)) {\r\n                return recordsByPK.get(pkValue);\r\n            } else {\r\n                // invalid pk value\r\n                throw new PrimaryKeyException(4, pkValue);\r\n            }\r\n        } else {\r\n            throw new PrimaryKeyException(5, new InvalidDataTypeException(pkValue, primaryAttribute).getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * creates a record and inserts it into all table collections\r\n     * as well as pages\r\n     * \r\n     * @param values values of the record\r\n     * @return true if record creation is successful\r\n     * @throws InvalidDataTypeException\r\n     * @throws PrimaryKeyException\r\n     */\r\n    public boolean insertRecord(String[] values) throws InvalidDataTypeException, PrimaryKeyException, TableException, UniqueException {\r\n        if(values.length < attributes.size() || values.length > attributes.size()){\r\n            throw new TableException(4, \"\");\r\n        }\r\n        if(values.length > attributes.size()){\r\n            throw new TableException(3, \"\");\r\n        }\r\n        if (Type.validateAll(values, attributes)) {\r\n\r\n\r\n            Record record = new Record(new ArrayList<String>(Arrays.asList(values)), attributes);\r\n            this.insertRecord(record);\r\n            return true;\r\n        } else {\r\n            // creation of record failed\r\n            throw new InvalidDataTypeException(values, attributes);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * returns the index of a given record\r\n     * the index is based on the order of insertion\r\n     * @param record record to get the index\r\n     * @return\r\n     */\r\n    public int getRecordIndex(Record record){\r\n        for (int i = 0; i < records.size(); i++) {\r\n            if(records.get(i).equals(record)){\r\n                return i;\r\n            }\r\n        }\r\n        // this should not happen\r\n        return -1;\r\n    }\r\n\r\n    public boolean insertRecord(Record record) throws PrimaryKeyException {\r\n                    \r\n        // check if this primary key exists\r\n        if(this.recordsByPK.containsKey(record.getPrimaryObject())){\r\n            String rowOccupied = String.valueOf(getRecordIndex(record));\r\n            throw new PrimaryKeyException(2, rowOccupied);\r\n        }\r\n\r\n        this.records.add(record);\r\n        this.recordsByPK.put(record.getValueAtColumn(primaryIndex), record);\r\n        // if there are no pages create one\r\n        if (this.pages.size() == 0) {\r\n            Page page = new Page(this.primaryIndex, 1);\r\n            this.pages.add(page);\r\n        }\r\n        addRecordToPage(record);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * finds record based on primary key from all table collections\r\n     * \r\n     * @param pkValue value of primary key\r\n     * @return true if removal successful\r\n     * @throws PrimaryKeyException\r\n     * @throws InvalidDataTypeException\r\n     */\r\n    public boolean removeRecordByPK(String pkValue) throws PrimaryKeyException, InvalidDataTypeException {\r\n        if (Type.validateType(pkValue, primaryAttribute)) {\r\n            // convert the value to an object\r\n            Object pkObject = Type.getObjFromType(pkValue, primaryAttribute.getType());\r\n\r\n            // validate key value\r\n            if (recordsByPK.containsKey(pkObject)) {\r\n\r\n                recordsByPK.remove(pkObject);\r\n                return true;\r\n            } else {\r\n                throw new PrimaryKeyException(4, pkValue);\r\n            }\r\n        } else {\r\n            throw new PrimaryKeyException(5, new InvalidDataTypeException(pkValue, primaryAttribute).getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * finds a record based on primary key and updates it\r\n     * \r\n     * @param pkValue  value of primary key\r\n     * @param column   column to update\r\n     * @param newEntry new value to insert\r\n     * @return true if update successful\r\n     * @throws TableException\r\n     * @throws PrimaryKeyException\r\n     * @throws InvalidDataTypeException\r\n     */\r\n    public boolean updateRecordByPK(String pkValue, String column, String newEntry)\r\n            throws TableException, PrimaryKeyException, InvalidDataTypeException {\r\n        if (Type.validateType(pkValue, primaryAttribute)) {\r\n            if (isValidColumn(column)) {\r\n                Attribute a = attributesByCol.get(column);\r\n                Object pkObject = Type.getObjFromType(pkValue, primaryAttribute.getType());\r\n                // if both the column and the pk are valid, then validate data type\r\n                if (Type.validateType(newEntry, a)) {\r\n                    Object newEntryObject = Type.getObjFromType(newEntry, a.getType());\r\n                    Record r = recordsByPK.remove(pkObject); // remove record from the map\r\n                    // this.records.remove(pkObject); // remove record from array\r\n                    removeRecordFromPage(r);// remove record from page\r\n                    r.updateAtColumn(getColumnIndex(column), newEntryObject); // update record\r\n                    recordsByPK.put(pkObject, r); // read the updated record\r\n                    addRecordToPage(r); // add record to page again\r\n                } else {\r\n                    throw new InvalidDataTypeException(newEntry, a);\r\n                }\r\n            } else {\r\n                throw new TableException(1, column);\r\n            }\r\n        } else {\r\n            throw new PrimaryKeyException(5, new InvalidDataTypeException(pkValue, primaryAttribute).getMessage());\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * returns the index of a specific attribute\r\n     * \r\n     * @param columnName column name of the attribute\r\n     * @return the index of that attribute in table\r\n     */\r\n    private int getColumnIndex(String columnName) {\r\n        int idx = 0;\r\n        for (int i = 0; i < attributes.size(); i++) {\r\n            Attribute a = attributes.get(i);\r\n            if (a.getName().equalsIgnoreCase(columnName)) {\r\n                idx = i;\r\n                break;\r\n            }\r\n        }\r\n        return idx;\r\n    }\r\n\r\n    /**\r\n     * checks if the provided column name exists in this table\r\n     * \r\n     * @param column the name of the column\r\n     */\r\n    public boolean isValidColumn(String column) {\r\n        return attributesByCol.keySet().contains(column);\r\n    }\r\n\r\n    /**\r\n     * counts how many records this table has\r\n     * \r\n     * @return\r\n     */\r\n    public int getNumberOfRecords() {\r\n        return records.size();\r\n    }\r\n\r\n    /**\r\n     * returns the table as a string in a nice format\r\n     * \r\n     * @return formatted table\r\n     */\r\n    public String formatResults(ArrayList<Attribute> columnAttr, ArrayList<Record> recordsToShow) {\r\n        String format = \"|\";\r\n        String result = \"\";\r\n        int len = 1;\r\n        String dash;\r\n        Object[] headers = new Object[columnAttr.size()];\r\n        for (int i = 0; i < columnAttr.size(); i++) {\r\n            Attribute a = columnAttr.get(i);\r\n            headers[i] = columnAttr.get(i).getName().toUpperCase();\r\n            if (a.getType() == Type.VARCHAR || a.getType() == Type.CHAR) {\r\n                int temp = Math.max(a.getName().length() + 2, a.getN() + 2);\r\n                format += \"%-\" + temp + \"s|\";\r\n                len += temp + 1;\r\n            } else {\r\n                int temp = (a.getName().length() + 2);\r\n                format += \"%-\" + temp + \"s|\";\r\n                len += temp + 1;\r\n            }\r\n        }\r\n        // create dashed line\r\n        dash = String.format(\"%0\" + len + \"d\", 0).replace(\"0\", \"-\");\r\n        // add the header to result\r\n        result = dash + \"\\n\" + String.format(format, headers) + \"\\n\" + dash;\r\n\r\n        // specific columns from all the records\r\n        for (Record r : recordsToShow) {\r\n            ArrayList<Object> entries = new ArrayList<>();\r\n            for (Attribute a : columnAttr) {\r\n                entries.add(r.getValueAtColumn(getColumnIndex(a.getName())));\r\n            }\r\n            result += \"\\n\" + String.format(format, entries.toArray());\r\n        }\r\n\r\n        // bottom line\r\n        result += \"\\n\" + dash;\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * returns a view of the table (schema)\r\n     * \r\n     * @return string view\r\n     */\r\n    public String displayTableSchema() {\r\n        String str = \"Table Name: \" + this.getName() + \"\\n\" + \"Table Schema: \\n\";\r\n        for (Attribute a : attributes) {\r\n            str += \"\\t\" + a + \"\\n\";\r\n        }\r\n        return str;\r\n    }\r\n\r\n    /**\r\n     * returns table information\r\n     * \r\n     * @return table info as string\r\n     */\r\n    public String displayTableInfo() {\r\n        String str = displayTableSchema() +\r\n                \"Pages: \" + this.pages.size() + \"\\n\" +\r\n                \"Record: \" + this.records.size();\r\n        return str;\r\n    }\r\n\r\n    /**\r\n     * selects infomation from the current table by columns\r\n     * \r\n     * @param columns the column names\r\n     * @return string formatted with the table info\r\n     * @throws TableException if columns are invalid\r\n     */\r\n    public String select(String[] columns) throws TableException {\r\n        ArrayList<Attribute> selectAttributes = new ArrayList<>();\r\n        // validate all columns\r\n        for (String c : columns) {\r\n            isValidColumn(c);\r\n            selectAttributes.add(attributesByCol.get(c));\r\n        }\r\n\r\n        return formatResults(selectAttributes, this.records);\r\n    }\r\n\r\n    /**\r\n     * selects and returns all the records from this table\r\n     * \r\n     * @return string records formatted\r\n     */\r\n    public String selectAll() {\r\n        return formatResults(this.attributes, this.records);\r\n\r\n    }\r\n\r\n    /**\r\n     * adds a given record to the pages of this table\r\n     * \r\n     * @param r\r\n     */\r\n    public void addRecordToPage(Record r) {\r\n        Page page;\r\n        boolean inserted = false;\r\n\r\n        for (int i = 0; i < pages.size(); i++) {\r\n            page = pages.get(i);\r\n\r\n            if (inserted) {\r\n                break;\r\n            }\r\n            // does the record belong in this page?\r\n            int index = 0;\r\n            if (index > -1) {\r\n                page.insertRecordAt(r, index);\r\n                inserted = true;\r\n            } else { // if this is the last page\r\n                     // and the record was not found to be less than any item\r\n                     // then it must be greater than all\r\n                if (i == pages.size() - 1 && !inserted) {\r\n                    page.addLast(r);\r\n                    inserted = true;\r\n                }\r\n\r\n            }\r\n            // if the addition overflows the page split\r\n            if (page.overflow()) {\r\n                pages.add(i + 1, page.split(0));\r\n                inserted = true;\r\n            }\r\n            if(inserted){\r\n                mostRecentPage = pages.get(i);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * remove a record from the page\r\n     * @param r\r\n     */\r\n    public void removeRecordFromPage(Record r){\r\n        for(Page page: this.pages){\r\n            if(page.containsRecord(r)){\r\n                page.removeRecord(r);\r\n                mostRecentPage = page;\r\n            }\r\n        }\r\n    }\r\n\r\n    /*\r\n     * returns a page based on its number\r\n     */\r\n    public Page getPageByPNum(int num) {\r\n        return pages.get(num);\r\n    }\r\n\r\n    /*\r\n     * returns all pages\r\n     */\r\n    public ArrayList<Page> getPages() {\r\n        return this.pages;\r\n    }\r\n\r\n    /**\r\n     * converts the entire table into Bytes for the catalog to use\r\n     * \r\n     * @return byte[]\r\n     */\r\n    public byte[] convertTableObjectToBytes()\r\n    {\r\n        byte[] bb = new byte[0];\r\n\r\n        bb = Type.concat(bb, getTableHeaderInfoForCatalog());\r\n        bb = Type.concat(bb, convertAllAttributestoBytes());\r\n        \r\n        return bb;\r\n    }\r\n\r\n    /**\r\n     * Turns all of the table's attributes into a byte array\r\n     * @return byte[]\r\n     */\r\n    public byte[] convertAllAttributestoBytes()\r\n    {\r\n        byte[] bb = new byte[0];\r\n\r\n        for (Attribute attr : this.attributes) \r\n        {\r\n            bb = Type.concat(bb, convertAttributeToBytes(attr));\r\n        }\r\n\r\n        return bb;\r\n    }\r\n\r\n    /**\r\n     * Turns a single attribute into bytes\r\n     * \r\n     * @param attr - the attribute we are converting\r\n     * @return byte[]\r\n     */\r\n    public byte[] convertAttributeToBytes(Attribute attr) \r\n    {\r\n        byte[] bb = new byte[0];\r\n\r\n        int attributeNameLength = attr.getName().length();\r\n        String attributeName = attr.getName();\r\n        int attributeType;\r\n        int attributeN = 0;\r\n\r\n        switch (attr.getType()) {\r\n            case BOOLEAN:\r\n                attributeType = Catalog.BOOLEAN;\r\n                break;\r\n            case CHAR:\r\n                attributeType = Catalog.CHAR;\r\n                attributeN = attr.getN();\r\n                break;\r\n            case DOUBLE:\r\n                attributeType = Catalog.DOUBLE;\r\n                break;\r\n            case INTEGER:\r\n                attributeType = Catalog.INTEGER;\r\n                break;\r\n            case VARCHAR:\r\n                attributeType = Catalog.VARCHAR;\r\n                attributeN = attr.getN();\r\n                break;\r\n            default:\r\n                attributeType = 0;\r\n                break;\r\n        }\r\n\r\n        boolean isPrimaryKey = attr.isIsPrimaryKey();\r\n\r\n        bb = Type.concat(bb, Type.convertIntToByteArray(attributeNameLength));\r\n        bb = Type.concat(bb, Type.convertStringToByteArray(attributeName));\r\n        bb = Type.concat(bb, Type.convertIntToByteArray(attributeType));\r\n        bb = Type.concat(bb, Type.convertIntToByteArray(attributeN));\r\n        bb = Type.concat(bb, Type.convertBooleanToByteArray(isPrimaryKey));\r\n\r\n        return bb;\r\n    }\r\n\r\n    /**\r\n     * Gets the length of the table name, the table name, and the number of attributes\r\n     * associated with the table\r\n     * @return\r\n     */\r\n    public byte[] getTableHeaderInfoForCatalog() \r\n    {\r\n        byte[] bb = new byte[0];\r\n\r\n        int tableNameLength = this.name.length();\r\n        int numOfAttributes = this.attributes.size();\r\n\r\n        bb = Type.concat(bb, Type.convertIntToByteArray(tableNameLength));\r\n        bb = Type.concat(bb, Type.convertStringToByteArray(this.name));\r\n        bb = Type.concat(bb, Type.convertIntToByteArray(numOfAttributes));\r\n\r\n        return bb;\r\n    }\r\n\r\n    public boolean removeAttribute(String attribute_name) {\r\n        // TODO: actually... i forgot about changing records so i need to do that\r\n        return attributes.removeIf(a -> a.getName().equalsIgnoreCase(attribute_name));\r\n    }\r\n\r\n    public boolean addAttribute(Attribute attribute, String value) {\r\n        // TODO: add attribute to record\r\n        return attributes.add(attribute);\r\n    }\r\n}
===================================================================
diff --git a/Main/src/Table.java b/Main/src/Table.java
--- a/Main/src/Table.java	
+++ b/Main/src/Table.java	
@@ -158,7 +158,7 @@
      * @throws InvalidDataTypeException
      * @throws PrimaryKeyException
      */
-    public boolean insertRecord(String[] values) throws InvalidDataTypeException, PrimaryKeyException, TableException, UniqueException {
+    public boolean insertRecord(String[] values) throws InvalidDataTypeException, PrimaryKeyException, TableException, ConstraintException {
         if(values.length < attributes.size() || values.length > attributes.size()){
             throw new TableException(4, "");
         }
Index: Main/test/TableTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import org.junit.*;\r\n\r\nimport static org.junit.Assert.assertNotNull;\r\nimport static org.junit.Assert.assertTrue;\r\n\r\nimport java.io.ByteArrayInputStream;\r\nimport java.nio.ByteBuffer;\r\nimport java.nio.charset.Charset;\r\nimport java.nio.charset.StandardCharsets;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\n\r\npublic class TableTest {\r\n    String[] columns;\r\n    String[] columns2;\r\n    Type[] types;\r\n    Type[] types2;\r\n    Attribute a1;\r\n    Attribute a2;\r\n    ArrayList<Attribute> attributes;\r\n    ArrayList<Attribute> attributes2;\r\n    int wordMaxLen = 20;\r\n    Table table;\r\n    Table table2;\r\n\r\n    @Before\r\n    public void setupTables() throws PrimaryKeyException {\r\n        setupTable1();\r\n        setupTable2();\r\n    }\r\n\r\n    public void setupTable1() throws PrimaryKeyException {\r\n        // test adding a record to a table\r\n        columns = new String[] { \"name\", \"lastname\", \"age\" };\r\n        types = new Type[] { Type.VARCHAR, Type.VARCHAR, Type.INTEGER };\r\n        attributes = new ArrayList<>();\r\n        int pkid = 0;\r\n        createAttributes(pkid, columns, types, attributes);\r\n        Attribute pka = attributes.get(pkid);\r\n        table = new Table(\"person\", attributes);\r\n        ArrayList<String> d1 = new ArrayList<>(Arrays.asList(new String[] { \"carly\", \"maggiolo\", \"21\" }));\r\n        ArrayList<String> d2 = new ArrayList<>(Arrays.asList(new String[] { \"mark\", \"smith\", \"24\" }));\r\n        ArrayList<String> d3 = new ArrayList<>(Arrays.asList(new String[] { \"LongName\", \"ReallyLongLastName\", \"50\" }));\r\n        ArrayList<String> d4 = new ArrayList<>(\r\n                Arrays.asList(new String[] { \"Zendaya\", \"WhateverHerLastNameIs\", \"25\" }));\r\n        ArrayList<String> d5 = new ArrayList<>(Arrays.asList(new String[] { \"Benito\", \"bunny\", \"27\" }));\r\n        ArrayList<String> d6 = new ArrayList<>(Arrays.asList(new String[] { \"ferxxo\", \"feid\", \"23\" }));\r\n        ArrayList<String> d7 = new ArrayList<>(Arrays.asList(new String[] { \"pancon\", \"queso\", \"100\" }));\r\n        ArrayList<String> d8 = new ArrayList<>(Arrays.asList(new String[] { \"George\", \"Lopez\", \"56\" }));\r\n        Page.setCapacity(200);\r\n        Record r1 = new Record(d1, attributes);\r\n        Record r2 = new Record(d2, attributes);\r\n        Record r3 = new Record(d3, attributes);\r\n        Record r4 = new Record(d4, attributes);\r\n        Record r5 = new Record(d5, attributes);\r\n        Record r6 = new Record(d6, attributes);\r\n        Record r7 = new Record(d7, attributes);\r\n        Record r8 = new Record(d8, attributes);\r\n        table.insertRecord(r1);\r\n        table.insertRecord(r2);\r\n        table.insertRecord(r3);\r\n        table.insertRecord(r4);\r\n        table.insertRecord(r5);\r\n        table.insertRecord(r6);\r\n        table.insertRecord(r7);\r\n        table.insertRecord(r8);\r\n\r\n    }\r\n\r\n    public void setupTable2() throws PrimaryKeyException {\r\n        columns2 = new String[] { \"id\", \"name\", \"dep\" };\r\n        types2 = new Type[] { Type.INTEGER, Type.VARCHAR, Type.VARCHAR };\r\n        attributes2 = new ArrayList<>();\r\n        int pkid = 0;\r\n        createAttributes(pkid, columns2, types2, attributes2);\r\n        a2 = attributes2.get(pkid);\r\n        table2 = new Table(\"student\", attributes2);\r\n        Page.setCapacity(200);\r\n        ArrayList<String> d1 = new ArrayList<>(Arrays.asList(new String[] { \"1234\", \"carly\", \"CSCI\" }));\r\n        ArrayList<String> d2 = new ArrayList<>(Arrays.asList(new String[] { \"5678\", \"dell\", \"GCIS\" }));\r\n        Record r1 = new Record(d1, attributes2);\r\n        Record r2 = new Record(d2, attributes2);\r\n        table2.insertRecord(r1);\r\n        table2.insertRecord(r2);\r\n    }\r\n\r\n    @Test\r\n    public void testTableSelectByColumn() {\r\n        try {\r\n            System.out.println(table.select(new String[] { \"name\", \"lastname\" }));\r\n        } catch (TableException e) {\r\n            System.out.println(e.getMessage());\r\n        }\r\n    }\r\n\r\n    @Test\r\n    public void testTableSelect() {\r\n        System.out.println(table.selectAll());\r\n    }\r\n\r\n    @Test\r\n    public void testTableSchema() {\r\n        System.out.println(table.displayTableSchema());\r\n    }\r\n\r\n    @Test\r\n    public void testTableInfo() {\r\n        System.out.println(table.displayTableInfo());\r\n    }\r\n\r\n    @Test\r\n    public void testGetRecordByPKWithValidKey() {\r\n        String pkvalue = \"carly\"; // this is valid in table 1\r\n        Record r = null;\r\n\r\n        try {\r\n            r = table.getRecordByPK(pkvalue);\r\n        } catch (PrimaryKeyException e) {\r\n            System.out.println(e.getMessage());\r\n        } catch (InvalidDataTypeException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        assertNotNull(r);\r\n    }\r\n\r\n    @Test\r\n    public void testGetRecordByPKWithInvalidTypeKey() {\r\n        String str = \"cute\"; // the pk for table2 is an int\r\n        Record r = null;\r\n        String msgExpected = new PrimaryKeyException(5, new InvalidDataTypeException(str, a2).getMessage())\r\n                .getMessage();\r\n        String msgGot = \"\";\r\n        try {\r\n            r = table2.getRecordByPK(str);\r\n        } catch (PrimaryKeyException e) {\r\n            msgGot = e.getMessage();\r\n        } catch (InvalidDataTypeException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        assertTrue(r == null && msgGot.equals(msgExpected));\r\n    }\r\n\r\n    @Test\r\n    public void testGetRecordByPKWithInvalidKey() {\r\n        String str = \"cute\"; // there is no key with this name\r\n        Record r = null;\r\n        String msgExpected = new PrimaryKeyException(4, str).getMessage();\r\n        String msgGot = \"\";\r\n        try {\r\n            r = table.getRecordByPK(str);\r\n        } catch (PrimaryKeyException e) {\r\n            msgGot = e.getMessage();\r\n        } catch (InvalidDataTypeException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        assertTrue(r == null && msgGot.equals(msgExpected));\r\n    }\r\n\r\n    @Test\r\n    public void testRemoveRecordByPrimaryKey() {\r\n        // remove carly from records of table1\r\n        String name = \"carly\";\r\n\r\n        boolean res = false;\r\n\r\n        try {\r\n            res = table.removeRecordByPK(name);\r\n        } catch (PrimaryKeyException e) {\r\n            // TODO Auto-generated catch block\r\n        } catch (InvalidDataTypeException e) {\r\n            // TODO Auto-generated catch block\r\n        }\r\n\r\n        assertTrue(res);\r\n    }\r\n\r\n    @Test\r\n    public void testRemoveRecordByPrimaryKeyWithInvalidKey() {\r\n        // remove carly from records of table1\r\n        String name = \"jackson\";\r\n        boolean res = false;\r\n        String msgExpected = new PrimaryKeyException(4, name).getMessage();\r\n        String msgGot = \"\";\r\n\r\n        try {\r\n            res = table.removeRecordByPK(name);\r\n        } catch (PrimaryKeyException e) {\r\n            msgGot = e.getMessage();\r\n        } catch (InvalidDataTypeException e) {\r\n            // TODO Auto-generated catch block\r\n        }\r\n\r\n        assert (res == false && msgExpected.equals(msgGot));\r\n    }\r\n\r\n    @Test\r\n    public void testInsertRecordValid(){\r\n        // this is a valid record that be inserted into table\r\n        boolean res = false;\r\n        String[] d1 = new String[] { \"4563\", \"madelina\", \"FINC\" };\r\n        try {\r\n            res = table2.insertRecord(d1);\r\n        } catch (InvalidDataTypeException e) {\r\n            // this shouldn't fail\r\n        } catch (PrimaryKeyException e) {\r\n            // TODO Auto-generated catch block\r\n            e.printStackTrace();\r\n        } catch (TableException e) {\r\n            e.printStackTrace();\r\n        } catch (UniqueException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    @Test\r\n    public void testInsertRecordInValidPKType(){\r\n        // this is a valid record that be inserted into table\r\n        boolean res = false;\r\n        String[] d1 = new String[] { \"false\", \"madelina\", \"FINC\" };\r\n        String msgExpected = new InvalidDataTypeException(d1, attributes2).getMessage();\r\n        String msgGot = \"\";\r\n\r\n        try {\r\n            res = table2.insertRecord(d1);\r\n        } catch (InvalidDataTypeException e) {\r\n            // this should fail\r\n            msgGot = e.getMessage();\r\n        } catch (PrimaryKeyException e) {\r\n            // TODO Auto-generated catch block\r\n            e.printStackTrace();\r\n        } catch (TableException e) {\r\n            e.printStackTrace();\r\n        } catch (UniqueException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        assertTrue(!res && msgExpected.equals(msgGot));\r\n    }\r\n\r\n    @Test\r\n    public void testInsertRecordDuplicatePK(){\r\n         // there is a record with this pk value\r\n         boolean res = false;\r\n         String[] d1 = new String[] { \"1234\", \"madelina\", \"FINC\" };\r\n         String msgExpected = new PrimaryKeyException(2, \"0\").getMessage();\r\n         String msgGot = \"\";\r\n \r\n         try {\r\n             res = table2.insertRecord(d1);\r\n         } catch (InvalidDataTypeException e) {\r\n             // this should fail\r\n             msgGot = e.getMessage();\r\n         } catch (PrimaryKeyException e) {\r\n             // TODO Auto-generated catch block\r\n             msgGot = e.getLocalizedMessage();\r\n         } catch (TableException e) {\r\n             e.printStackTrace();\r\n         } catch (UniqueException e) {\r\n             e.printStackTrace();\r\n         }\r\n        assertTrue(!res && msgExpected.equals(msgGot));\r\n    }\r\n\r\n    @Test\r\n    public void testUpdateTableByPK(){\r\n        System.out.println(table.selectAll());\r\n        try {\r\n            table.updateRecordByPK(\"carly\", \"age\", \"15\");\r\n            assert(table.getRecordByPK(\"carly\").getValueAtColumn(2).equals(15));\r\n        } catch (TableException e) {\r\n            // TODO Auto-generated catch block\r\n            System.out.println(e.getMessage());\r\n        } catch (PrimaryKeyException e) {\r\n            // TODO Auto-generated catch block\r\n            System.out.println(e.getMessage());\r\n        } catch (InvalidDataTypeException e) {\r\n            // TODO Auto-generated catch block\r\n            System.out.println(e.getMessage());\r\n        }\r\n        \r\n    }\r\n\r\n    public void createAttributes(int pkidx, String[] c, Type[] t, ArrayList<Attribute> attr) {\r\n        for (int i = 0; i < c.length; i++) {\r\n            Attribute a = new Attribute(c[i], t[i], i == pkidx ? true : false, false, false,\r\n                    t[i] == Type.VARCHAR || t[i] == Type.CHAR ? 20 : 0);\r\n            attr.add(a);\r\n        }\r\n\r\n        attr.get(0).setIsPrimaryKey(true);\r\n\r\n        // for(Attribute a: attributes){\r\n        // System.out.println(a);\r\n        // }\r\n    }\r\n}\r\n
===================================================================
diff --git a/Main/test/TableTest.java b/Main/test/TableTest.java
--- a/Main/test/TableTest.java	
+++ b/Main/test/TableTest.java	
@@ -3,10 +3,6 @@
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 
-import java.io.ByteArrayInputStream;
-import java.nio.ByteBuffer;
-import java.nio.charset.Charset;
-import java.nio.charset.StandardCharsets;
 import java.util.ArrayList;
 import java.util.Arrays;
 
@@ -210,7 +206,7 @@
             e.printStackTrace();
         } catch (TableException e) {
             e.printStackTrace();
-        } catch (UniqueException e) {
+        } catch (ConstraintException e) {
             e.printStackTrace();
         }
     }
@@ -233,7 +229,7 @@
             e.printStackTrace();
         } catch (TableException e) {
             e.printStackTrace();
-        } catch (UniqueException e) {
+        } catch (ConstraintException e) {
             e.printStackTrace();
         }
 
@@ -258,7 +254,7 @@
              msgGot = e.getLocalizedMessage();
          } catch (TableException e) {
              e.printStackTrace();
-         } catch (UniqueException e) {
+         } catch (ConstraintException e) {
              e.printStackTrace();
          }
         assertTrue(!res && msgExpected.equals(msgGot));
